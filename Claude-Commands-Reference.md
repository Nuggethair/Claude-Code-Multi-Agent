# Claude Commands 完整参考文档

---

## 4.3 Claude Commands 开发工作流指令体系

本文档详细解读 `.claude/commands`
文件夹中的所有指令文件，展示其实现流程和使用方法。

---

### 4.3.1 Kiro 工作流系统

Kiro 是一个完整的功能开发工作流系统，提供从需求分析到实现的结构化流程。

---

#### 1. 规格说明创建 - `/kiro:spec`

**指令格式**: `/kiro:spec [feature name or rough idea]`

**功能描述**: 创建完整的功能规格说明，从需求到实现计划

**实现流程**:

1. **需求收集阶段**
   - 生成初始需求文档 (requirements.md)
   - 使用 EARS 格式编写验收标准
   - 用户反馈循环直到批准

2. **设计文档阶段**
   - 创建设计文档 (design.md)
   - 进行必要的研究和上下文构建
   - 包含架构、组件、数据模型等

3. **任务列表阶段**
   - 生成实现计划 (tasks.md)
   - 将设计转换为可执行的编码任务
   - 优先考虑测试驱动开发

**输出文件结构**:

```
.kiro/specs/{feature_name}/
├── requirements.md - 需求和验收标准
├── design.md - 架构设计
└── tasks.md - 实现任务列表
```

---

#### 2. 设计文档生成 - `/kiro:design`

**指令格式**: `/kiro:design [feature name]`

**功能描述**: 基于已批准的需求创建详细的设计文档

**实现流程**:

1. **研究阶段**
   - 识别需要研究的技术领域
   - 收集相关信息和最佳实践
   - 引用来源和包含相关链接

2. **设计创建**
   - 概述 (Overview)
   - 架构 (Architecture)
   - 组件和接口 (Components and Interfaces)
   - 数据模型 (Data Models)
   - 错误处理 (Error Handling)
   - 测试策略 (Testing Strategy)

3. **评审循环**
   - 使用 `userInput` 工具请求用户审查
   - 根据反馈修改设计
   - 直到获得明确批准

---

#### 3. 任务列表生成 - `/kiro:task`

**指令格式**: `/kiro:task [feature name]`

**功能描述**: 将设计文档转换为具体的实现任务列表

**实现流程**:

1. **任务转换**
   - 将功能设计转换为代码生成提示
   - 优先考虑最佳实践和渐进开发
   - 确保每个任务都建立在前一个任务之上

2. **任务格式化**
   - 编号复选框列表（最多两级层次）
   - 每个任务包含明确目标
   - 引用具体的需求文档

3. **质量保证**
   - 任务必须是可执行的编码活动
   - 排除非编码活动（部署、用户测试等）
   - 确保覆盖所有需求

**任务格式示例**:

```markdown
-
  1. [ ] 设置项目结构和核心接口
  - 创建模型、服务、存储库目录结构
  - 定义系统边界接口
  - _需求: 1.1_

- [ ] 2.1 创建核心数据模型接口
  - 编写 TypeScript 接口
  - 实现验证函数
  - _需求: 2.1, 3.3, 1.2_
```

---

#### 4. 任务执行 - `/kiro:execute`

**指令格式**: `/kiro:execute [feature name] [task description or task number]`

**功能描述**: 执行规格说明中的特定任务

**实现流程**:

1. **任务准备**
   - 读取 requirements.md、design.md、tasks.md
   - 识别要执行的特定任务
   - 如果有子任务，从子任务开始

2. **任务执行**
   - 专注于一个任务
   - 根据需求验证实现
   - 完成后停止，等待用户审查

3. **质量控制**
   - 不自动继续下一个任务
   - 让用户审查每个完成的任务
   - 提供任务建议如果用户未指定

---

#### 5. 快速开发助手 - `/kiro:vibe`

**指令格式**: `/kiro:vibe [problem or question]`

**功能描述**: 提供快速的开发帮助，采用轻松友好的方式

**特点**:

- 知识渊博但不说教
- 支持性而非权威性
- 简洁直接的回应
- 优先提供可操作信息
- 包含相关代码片段和配置示例

---

### 4.3.2 多代理工作流系统

---

#### 1. 自动化代理工作流 - `/agent-workflow`

**指令格式**: `/agent-workflow <FEATURE_DESCRIPTION>`

**功能描述**: 执行完整的开发工作流，使用智能子代理链和质量门控

**实现流程**:

1. **规格分析阶段** - spec-analyst 子代理
   - 生成 requirements.md
   - 创建 user-stories.md
   - 制定 acceptance-criteria.md

2. **架构设计阶段** - spec-architect 子代理
   - 创建 architecture.md
   - 设计 api-spec.md
   - 决定 tech-stack.md

3. **代码实现阶段** - spec-developer 子代理
   - 基于规格实现核心功能
   - 遵循最佳实践和编码标准
   - 创建模块化、可维护的代码结构

4. **质量验证阶段** - spec-validator 子代理
   - 评估代码质量指标（0-100%）
   - 检查架构合规性
   - 安全漏洞和性能问题分析

5. **质量门控决策**
   - 分数 ≥95%：进入测试阶段
   - 分数 <95%：回到规格分析阶段

6. **测试生成阶段** - spec-tester 子代理
   - 创建综合单元测试套件
   - 集成测试关键工作流
   - 端到端测试场景

**质量门控机制**:

- 最多3次迭代防止无限循环
- 预期质量提升：80-90% → 90-95% → 95%+

---

#### 2. PRP 执行系统

##### PRP 生成 - `/generate-prp`

**指令格式**: `/generate-prp <功能文件>`

**功能描述**: 为通用功能实现生成完整的 PRP (Project Requirements Protocol)

**研究过程**:

1. **代码库分析**
   - 搜索类似功能/模式
   - 识别要引用的文件
   - 注意现有约定

2. **外部研究**
   - 在线搜索类似功能
   - 库文档和具体URL
   - 实现示例和最佳实践

3. **PRP 生成**
   - 使用 `PRPs/templates/prp_base.md` 模板
   - 包含文档URL和代码示例
   - 列出按顺序完成的任务

##### PRP 执行 - `/execute-prp`

**指令格式**: `/execute-prp <PRP 文件>`

**执行流程**:

1. **加载 PRP** - 读取和理解所有上下文
2. **超级思考** - 进入UltraThink模式创建综合计划
3. **执行计划** - 实现所有代码
4. **验证** - 运行验证命令并修复失败
5. **完成** - 确保所有检查清单项目完成

---

#### 3. 规格任务执行 - `/spec-execute-task`

**指令格式**: `/spec-execute-task [task-id]`

**功能描述**: 执行规格驱动开发计划中的特定任务，然后自动继续所有剩余任务

**自动执行行为**:

1. **初始任务执行**: 执行指定任务或下一个未完成任务
2. **自动接管**: 第一个任务完成后系统自动接管
3. **连续执行**: 自动按顺序执行所有剩余未完成任务
4. **无用户干预**: 用户无需批准每个任务
5. **进度跟踪**: 显示实时进度并在tasks.md中标记完成
6. **恢复能力**: 可从中断处恢复

**特性**:

- ✅ 一键启动完整自动化
- ✅ 零用户干预
- ✅ 持久状态保存
- ✅ 中断恢复
- ✅ 进度监控
- ✅ 错误恢复

---

### 4.3.3 分析和反思系统

---

#### 1. 增强分析思维 - `/think-harder`

**指令格式**: `/think-harder [problem or question]`

**功能描述**: 对复杂问题进行增强的分析思维

**深度分析协议**:

1. **问题澄清**
   - 定义核心问题和隐含假设
   - 建立范围、约束和成功标准
   - 暴露潜在歧义和多重解释

2. **多维度分析**
   - 结构分解：基本组件和依赖关系
   - 利益相关者视角：所有受影响方的观点
   - 时间分析：短期vs长期影响
   - 因果推理：原因-结果关系和反馈循环

3. **批判性评估**
   - 挑战初始假设和识别认知偏见
   - 生成和评估替代假设
   - 进行事前分析：什么可能出错
   - 评估机会成本和权衡

4. **综合和整合**
   - 连接不同领域的见解
   - 识别组件交互的涌现属性
   - 调和明显的矛盾
   - 开发解决问题过程的元见解

**输出结构**:

1. 问题重构
2. 关键见解
3. 推理链
4. 考虑的替代方案
5. 不确定性
6. 可操作建议

---

#### 2. 超级综合分析 - `/think-ultra`

**指令格式**: `/think-ultra [complex problem or question]`

**功能描述**: 激活最大认知处理能力，进行超级综合分析

**超级分析框架** (7个阶段):

**阶段1: 问题架构**

- 本体论分析：问题的根本性质
- 认识论检查：我们如何知道我们所知道的
- 语义分解：解构关键术语和概念
- 边界分析：包含、排除的内容
- 元问题识别：问题背后的问题

**阶段2: 多范式分析**

- 还原论方法：分解到最小可分析组件
- 整体系统观：涌现属性和交互
- 辩证推理：矛盾及其解决
- 现象学视角：主观体验
- 实用主义评估：实践vs理论

**阶段3: 跨学科整合**

- 科学方法论：假设形成、测试、验证
- 数学建模：定量关系和模式
- 哲学框架：逻辑一致性和伦理含义
- 历史分析：模式、先例和演化趋势
- 人类学观点：文化、社会和行为维度
- 经济分析：资源分配、激励和权衡

**阶段4: 时空尺度**

- 多时间尺度分析：即时、短期、中期、长期
- 代际思维：跨多代影响
- 空间尺度：局部、区域、国家、全球影响
- 分形分析：不同尺度的自相似模式
- 路径依赖：历史如何约束未来选择

**阶段5: 不确定性和风险建模**

- 概率推理：贝叶斯更新和置信区间
- 情景规划：多重未来路径
- 黑天鹅分析：低概率、高影响事件
- 反脆弱性评估：从混乱中受益
- 稳健性测试：各种压力条件下的性能

**阶段6: 决策理论和博弈论**

- 多标准决策分析：加权评估选项
- 战略互动：他人决策如何影响结果
- 机制设计：期望结果的最优系统架构
- 行为经济学：认知偏见和心理因素
- 进化稳定策略：时间推移中的持续性

**阶段7: 元认知反思**

- 认知偏见审计：系统识别思维错误
- 视角采取：钢铁侠对立观点
- 假设考古学：深入挖掘基础信念
- 推理透明度：使隐式逻辑显式
- 智力谦逊：承认限制和不确定性

---

#### 3. 指令改进反思 - `/reflection`

**指令格式**: `/reflection`

**功能描述**: 分析和改进Claude Code指令

**流程**:

1. **分析阶段**: 审查聊天历史和CLAUDE.md文件
2. **分析文档**: 使用TodoWrite工具跟踪改进领域
3. **交互阶段**: 向用户展示发现和改进想法
4. **实现阶段**: 修改CLAUDE.md文件
5. **输出格式**: 结构化分析、改进和最终指令

---

#### 4. 深度会话反思 - `/reflection-harder`

**指令格式**: `/reflection-harder`

**功能描述**: 全面的会话分析和学习捕获

**会话分析阶段**:

1. **问题和解决方案** - 遇到的问题、根本原因、实现的解决方案
2. **代码模式和架构** - 涌现的模式、设计决策、架构选择
3. **用户偏好和工作流** - 用户的工作方式、决策模式、质量标准
4. **系统理解** - 组件交互、关键路径、故障模式
5. **知识差距和改进** - 误解、缺失信息、更好的方法

**反思输出阶段**:

- 会话概述、解决的问题、建立的模式
- 用户偏好、系统关系、知识更新
- 命令和工具、未来改进、协作见解

---

### 4.3.4 GitHub 集成系统

---

#### 1. Pull Request 审查 - `/gh:review-pr`

**指令格式**: `/gh:review-pr [pr-number]`

**功能描述**: 进行详细的代码分析和GitHub PR审查

**审查流程**:

1. **PR获取**: 使用 `gh pr view` 获取PR详情
2. **差异分析**: 使用 `gh pr diff` 获取代码变更
3. **全面审查**:
   - PR功能概述
   - 代码质量和风格分析
   - 改进建议
   - 潜在问题和风险

4. **审查评论**: 使用GitHub API发布审查评论

**关注焦点**:

- 代码正确性
- 遵循项目约定
- 性能影响
- 测试覆盖率
- 安全考虑

**GitHub CLI 命令参考**:

```bash
# 列出PR
gh pr list

# 查看PR描述
gh pr view 78

# 查看PR代码变更
gh pr diff 78

# 发布审查评论
gh api repos/OWNER/REPO/pulls/PR_NUMBER/comments \
    --method POST \
    --field body="[your-comment]" \
    --field commit_id="[commitID]" \
    --field path="path/to/file" \
    --field line=lineNumber \
    --field side="RIGHT"
```

---

#### 2. 问题修复 - `/gh:fix-issue`

**指令格式**: `/gh:fix-issue [issue-number]`

**功能描述**: 分析和修复GitHub问题的完整工作流

**修复流程**:

**规划阶段**:

1. 使用 `gh issue view` 获取问题详情
2. 理解问题描述
3. 必要时提出澄清问题
4. 理解问题的先前技术
5. 将问题分解为小的、可管理的任务
6. 在新的scratchpad中记录计划

**创建阶段**:

1. 为问题创建新分支
2. 按照计划分小步骤解决问题
3. 每步后提交更改

**测试阶段**:

1. 如果有UI更改，使用puppeteer测试
2. 编写单元测试描述代码预期行为
3. 运行完整测试套件
4. 修复失败的测试
5. 确保所有测试通过

**Pull Request阶段**:

1. 开启PR并请求审查

---

### 4.3.5 知识管理和创作工具

---

#### 1. 技术突破文档 - `/eureka`

**指令格式**: `/eureka [breakthrough description]`

**功能描述**: 捕获技术突破并转换为可操作、可重用的文档

**主要操作**:

1. **创建文件**: `breakthroughs/YYYY-MM-DD-[brief-name].md`
2. **文档洞察**: 使用结构化模板
3. **更新索引**: 更新 `breakthroughs/INDEX.md`
4. **提取模式**: 提取可重用模式供未来参考

**文档模板结构**:

```markdown
# [突破标题]

**日期**: YYYY-MM-DD **标签**: #performance #architecture #algorithm

## 🎯 一句话总结

[简单术语中实现的内容]

## 🔴 问题

[阻止进展的具体挑战]

## 💡 洞察

[解锁解决方案的关键认识]

## 🛠️ 实现

[最小工作示例]

## 📊 影响

- 之前: [指标]
- 之后: [指标]
- 改进: [百分比/因子]

## 🔄 可重用模式

[抽象化可应用elsewhere的模式]

## 🔗 相关资源

[相关文档、问题或讨论链接]
```

**文件管理**:

1. 保存到 `breakthroughs/` 目录
2. 在 `breakthroughs/INDEX.md` 中添加条目
3. 使用一致标签以便未来搜索

**核心原则**:

- 快速行动：在上下文新鲜时捕获洞察
- 具体化：包含具体指标和代码
- 可重用性：始终提取可泛化模式
- 可搜索性：使用一致标签和清晰标题

---

#### 2. 自定义命令创建 - `/cc:create-command`

**指令格式**: `/cc:create-command [command-name] [description]`

**功能描述**: 创建新的Claude Code自定义命令

**创建流程**:

1. **命令分析**
   - 确定命令目的和范围
   - 选择适当位置（项目vs用户级别）
   - 分析类似现有命令的模式

2. **命令结构规划**
   - 定义必需参数和参数
   - 规划命令工作流和步骤
   - 识别必需工具和权限
   - 考虑错误处理和边缘情况

3. **命令创建**
   - 创建带有适当YAML前置元数据的命令文件
   - 包含全面文档
   - 添加使用示例和参数描述
   - 实现适当的参数处理

4. **质量保证**
   - 验证命令语法和结构
   - 测试命令功能
   - 确保适当工具权限
   - 根据最佳实践审查

**模板结构**:

```markdown
---
description: 命令简要描述
argument-hint: 预期参数格式
allowed-tools: 必需工具列表
---

# 命令名称

详细描述此命令的功能和使用时机

## 使用方法:

`/[category:]command-name [arguments]`

## 流程:

1. 逐步指令
2. 清晰工作流定义
3. 错误处理考虑

## 示例:

- 具体使用示例
- 不同参数组合

## 注意事项:

- 重要考虑
- 限制或要求
```

**最佳实践**:

- 保持命令专注和单一目的
- 使用描述性名称和清晰文档
- 在前置元数据中包含适当工具权限
- 提供有用示例和使用模式
- 优雅处理参数并进行验证
- 遵循现有命令约定
- 部署前彻底测试

---

## 总结

Claude Commands
系统提供了一个完整的开发工作流框架，从高级规格驱动开发到具体的代码实现，从问题分析到知识管理。这个系统的设计哲学是：

1. **结构化工作流**: 提供清晰的步骤和质量门控
2. **自动化集成**: 减少手动干预，提高效率
3. **知识积累**: 捕获和重用学习成果
4. **质量保证**: 内置验证和反馈机制
5. **灵活适应**: 支持不同复杂度的任务和问题

每个命令都有明确的目的、标准化的接口和详细的文档，确保开发者能够高效地利用AI助手进行软件开发工作。

---
